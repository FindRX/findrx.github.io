<!DOCTYPE html>
<html lang="en">
<head>
        <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>WhileRX | Hash Table (easy)</title>
    <link rel="shortcut icon" type="image/png" href="/favicon.png">
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico">
    <link rel="stylesheet" href="/theme/css/screen.css" type="text/css" />
    <link rel="stylesheet" href="/theme/css/pygments.css" type="text/css" />
    <link rel="stylesheet" href="/theme/css/print.css" type="text/css" media="print" />
    <meta name="generator" content="Pelican" />

    <meta name="keywords" content="hashtable,leetcode" />
</head>
<body>
    <header>
        <nav>
            <ul>
                <li><a href="/">Home</a></li>
                <li><a href="/tags">Tags</a></li>
                <li><a href="/categories">Categories</a></li>
                <li><a href="/archives">Archives</a></li>
            </ul>
        </nav>
        <div class="header_box">
            <h1><a href="/">WhileRX</a></h1>
        </div>
    </header>
    <div id="wrapper">
        <div id="content">            <h4 class="date">Nov 02, 2016</h4>

            <article class="post">
                <h2 class="title">
                    <a href="/hash-table-easy.html" rel="bookmark" title="Permanent Link to &quot;Hash Table (easy)&quot;">Hash Table (easy)</a>
                </h2>

                
                

                <p>If the key's range is not too large, array is a perfect hash-table.</p>
<p>If the key's range is small enough, a <code>char/int</code> integer is a perfect hash-table.</p>
<h3><a href="https://leetcode.com/problems/two-sum/">1. Two Sum</a></h3>
<p>Given a list of integers, return indices of two numbers such that they add up to a specific target.</p>
<ul>
<li>You can assume that each input could have exactly one solution.</li>
<li>Indices are zero-based.</li>
</ul>
<p>Example:</p>
<ul>
<li>Given nums = [2, 7, 11, 15], target = 9,</li>
<li>Because nums[0] + nums[1] = 2 + 7 = 9,</li>
<li>return [0, 1].</li>
</ul>
<p>C Solution:</p>
<div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">He</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">ind</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">He</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">Ht</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">He</span> <span class="o">**</span><span class="n">list</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">Ht</span> <span class="o">*</span><span class="nf">create</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">Ht</span> <span class="o">*</span><span class="n">ht</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">Ht</span><span class="p">));</span>
    <span class="n">ht</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
    <span class="n">ht</span><span class="o">-&gt;</span><span class="n">list</span> <span class="o">=</span> <span class="n">calloc</span><span class="p">(</span><span class="n">ht</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">He</span> <span class="o">*</span><span class="p">));</span>
    <span class="k">return</span> <span class="n">ht</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">find</span><span class="p">(</span><span class="k">struct</span> <span class="n">Ht</span> <span class="o">*</span><span class="n">ht</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">ind</span> <span class="o">=</span> <span class="n">val</span> <span class="o">%</span> <span class="n">ht</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ind</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">ind</span> <span class="o">=</span> <span class="o">-</span><span class="n">ind</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">He</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">ht</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">[</span><span class="n">ind</span><span class="p">];</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">==</span> <span class="n">val</span><span class="p">)</span> <span class="k">return</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">ind</span><span class="p">;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="k">struct</span> <span class="n">Ht</span> <span class="o">*</span><span class="n">ht</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">ind</span> <span class="o">=</span> <span class="n">val</span> <span class="o">%</span> <span class="n">ht</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ind</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">ind</span> <span class="o">=</span> <span class="o">-</span><span class="n">ind</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">He</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">He</span><span class="p">));</span>
    <span class="n">p</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
    <span class="n">p</span><span class="o">-&gt;</span><span class="n">ind</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>
    <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">ht</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">[</span><span class="n">ind</span><span class="p">];</span>
    <span class="n">ht</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span><span class="o">*</span> <span class="nf">twoSum</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numsSize</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
    <span class="k">struct</span> <span class="n">Ht</span> <span class="o">*</span><span class="n">ht</span> <span class="o">=</span> <span class="n">create</span><span class="p">();</span>
    <span class="n">insert</span><span class="p">(</span><span class="n">ht</span><span class="p">,</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numsSize</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">_ind</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">ht</span><span class="p">,</span> <span class="n">target</span> <span class="o">-</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">_ind</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">_ind</span><span class="p">;</span>
            <span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">insert</span><span class="p">(</span><span class="n">ht</span><span class="p">,</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>Python Solution:</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">twoSum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :type nums: List[int]</span>
<span class="sd">        :type target: int</span>
<span class="sd">        :rtype: List[int]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ni</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">num</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">target</span> <span class="o">-</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">ni</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">ni</span><span class="p">[</span><span class="n">target</span> <span class="o">-</span> <span class="n">num</span><span class="p">],</span> <span class="n">i</span><span class="p">)</span>
            <span class="n">ni</span><span class="p">[</span><span class="n">num</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
</pre></div>


<p>Summary:</p>
<ol>
<li>If we think the complexity of HashTable is O(N), then the solutions are O(N).</li>
<li>Except HashTable, we can also use the Brute Force whose complexity is O(N<sup>2</sup>), or sort it first and then use two points O(NlgN).</li>
<li>The time consumed by C solution is 3ms, beat 90%.</li>
<li>The python solution is quite slow 322ms, only beat 67%, I don't know why, maybe the time is meaningless in python.</li>
</ol>
<h3><a href="https://leetcode.com/problems/valid-sudoku/">36. Valid Sudoku</a></h3>
<p>Determine if a Sudoku is valid, according to: <a href="http://sudoku.com.au/TheRules.aspx">Sudoku Puzzles - The Rules</a>.</p>
<p>The Sudoku board could be partially filled, where empty cells are filled with the character '.'.</p>
<ul>
<li>A valid Sudoku board (partially filled) is not necessarily solvable. Only the filled cells need to be validated.</li>
</ul>
<p><img alt="valid sudoku" src="/images/valid-sudoku.png"></p>
<p>Solution:</p>
<div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">isValidSudoku</span><span class="p">(</span><span class="kt">char</span><span class="o">**</span> <span class="n">board</span><span class="p">,</span> <span class="kt">int</span> <span class="n">boardRowSize</span><span class="p">,</span> <span class="kt">int</span> <span class="n">boardColSize</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">sign</span><span class="p">[</span><span class="mi">27</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">boardRowSize</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">boardRowSize</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;.&#39;</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">flag</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">sign</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">flag</span> <span class="o">||</span> <span class="n">sign</span><span class="p">[</span><span class="mi">9</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">flag</span> <span class="o">||</span> <span class="n">sign</span><span class="p">[</span><span class="mi">18</span> <span class="o">+</span> <span class="n">i</span> <span class="o">/</span> <span class="mi">3</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="n">j</span> <span class="o">/</span> <span class="mi">3</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">flag</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
            <span class="n">sign</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">|=</span> <span class="n">flag</span><span class="p">;</span>
            <span class="n">sign</span><span class="p">[</span><span class="mi">9</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">|=</span> <span class="n">flag</span><span class="p">;</span>
            <span class="n">sign</span><span class="p">[</span><span class="mi">18</span> <span class="o">+</span> <span class="n">i</span> <span class="o">/</span> <span class="mi">3</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="n">j</span> <span class="o">/</span> <span class="mi">3</span><span class="p">]</span> <span class="o">|=</span> <span class="n">flag</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>Summary:</p>
<ol>
<li>There are 27 blocks which need to test.</li>
<li>The key point is the relation between flag's index and i &amp; j.</li>
<li>3ms, 49.45%</li>
</ol>
<h3><a href="https://leetcode.com/problems/single-number/">136. Single Number</a></h3>
<p>Given an array of integers, every element appears twice except for one. Find that single one.</p>
<ul>
<li>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</li>
</ul>
<p>C Solution:</p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">singleNumber</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numsSize</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numsSize</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">res</span> <span class="o">^=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>Summary:</p>
<ol>
<li>6ms, 32.17%</li>
<li>Same as following Problem 389. Find the Difference.</li>
</ol>
<h3><a href="https://leetcode.com/problems/two-sum-iii-data-structure-design/">170. Two Sum III - Data structure design</a></h3>
<p>Design and implement a TwoSum class. It should support the following operations: add and find.</p>
<p>add - Add the number to an internal data structure.
find - Find if there exists any pair of numbers which sum is equal to the value.</p>
<p>Example:</p>
<ul>
<li>add(1); add(3); add(5);</li>
<li>find(4) -&gt; true</li>
<li>find(7) -&gt; false</li>
</ul>
<p>Python Solution:</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">TwoSum</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        initialize your data structure here</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nums</span> <span class="o">=</span> <span class="p">{}</span>


    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add the number to an internal data structure.</span>
<span class="sd">        :rtype: nothing</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nums</span><span class="p">[</span><span class="n">number</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nums</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">number</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find if there exists any pair of numbers which sum is equal to the value.</span>
<span class="sd">        :type value: int</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nums</span><span class="p">:</span>
            <span class="n">theother</span> <span class="o">=</span> <span class="n">value</span> <span class="o">-</span> <span class="n">num</span>
            <span class="k">if</span> <span class="n">num</span> <span class="o">==</span> <span class="n">theother</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nums</span><span class="p">[</span><span class="n">num</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">True</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">theother</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nums</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="bp">False</span>
</pre></div>


<p>Summary:</p>
<ol>
<li>Hashtable (dictionary), 742ms, 63.67%.</li>
<li>This solution is for more add, less find. otherwise, during add, we can pre-sum and save the result into a hashtable.</li>
</ol>
<h3><a href="https://leetcode.com/problems/happy-number/">202. Happy Number</a></h3>
<p>Write an algorithm to determine if a number is "happy".</p>
<p>A happy number is a number defined by the following process: </p>
<ol>
<li>Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. </li>
<li>Those numbers for which this process ends in 1 are happy numbers.</li>
</ol>
<p>Example: </p>
<ul>
<li>19 is a happy number</li>
<li>1<sup>2</sup> + 9<sup>2</sup> = 82</li>
<li>8<sup>2</sup> + 2<sup>2</sup> = 68</li>
<li>6<sup>2</sup> + 8<sup>2</sup> = 100</li>
<li>1<sup>2</sup> + 0<sup>2</sup> + 0<sup>2</sup> = 1</li>
</ul>
<p>C Solution with HashTable:</p>
<div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">He</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">He</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">Ht</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">He</span> <span class="o">**</span><span class="n">list</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">Ht</span> <span class="o">*</span><span class="nf">create</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">Ht</span> <span class="o">*</span><span class="n">ht</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">Ht</span><span class="p">));</span>
    <span class="n">ht</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
    <span class="n">ht</span><span class="o">-&gt;</span><span class="n">list</span> <span class="o">=</span> <span class="n">calloc</span><span class="p">(</span><span class="n">ht</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">He</span> <span class="o">*</span><span class="p">));</span>
    <span class="k">return</span> <span class="n">ht</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="nf">find_or_insert</span><span class="p">(</span><span class="k">struct</span> <span class="n">Ht</span> <span class="o">*</span><span class="n">ht</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">ind</span> <span class="o">=</span> <span class="n">val</span> <span class="o">%</span> <span class="n">ht</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ind</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">ind</span> <span class="o">=</span> <span class="o">-</span><span class="n">ind</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">He</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">ht</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">[</span><span class="n">ind</span><span class="p">];</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">==</span> <span class="n">val</span><span class="p">)</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">He</span><span class="p">));</span>
    <span class="n">p</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
    <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">ht</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">[</span><span class="n">ind</span><span class="p">];</span>
    <span class="n">ht</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">bool</span> <span class="nf">isHappy</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">Ht</span> <span class="o">*</span><span class="n">ht</span> <span class="o">=</span> <span class="n">create</span><span class="p">();</span>
    <span class="kt">int</span> <span class="n">iht</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">36</span><span class="p">,</span> <span class="mi">49</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">81</span><span class="p">};</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">find_or_insert</span><span class="p">(</span><span class="n">ht</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">res</span> <span class="o">+=</span> <span class="n">iht</span><span class="p">[</span><span class="n">n</span> <span class="o">%</span> <span class="mi">10</span><span class="p">];</span>
            <span class="n">n</span> <span class="o">/=</span> <span class="mi">10</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>C Solution with Array as HashTable</p>
<div class="highlight"><pre><span></span><span class="cp">#define HTSIZE (9 * 9 * 63)</span>
<span class="kt">bool</span> <span class="nf">isHappy</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">ht</span><span class="p">[</span><span class="n">HTSIZE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="kt">int</span> <span class="n">iht</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">36</span><span class="p">,</span> <span class="mi">49</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">81</span><span class="p">};</span>
    <span class="k">do</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">res</span> <span class="o">+=</span> <span class="n">iht</span><span class="p">[</span><span class="n">n</span> <span class="o">%</span> <span class="mi">10</span><span class="p">];</span>
            <span class="n">n</span> <span class="o">/=</span> <span class="mi">10</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">res</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ht</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="n">ht</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>Summary:</p>
<ol>
<li>HashTable is used to detect the cycle.</li>
<li>And in this case, keys are not too large, so an array could do the job.</li>
<li>The first: 3ms, 4.72%; the second: 0ms, 16%</li>
</ol>
<h3><a href="https://leetcode.com/problems/count-primes/">204. Count Primes</a></h3>
<p>Count the number of prime numbers less than a non-negative number, n.</p>
<p>C Solution:</p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">countPrimes</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">flag</span> <span class="o">=</span> <span class="n">calloc</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">res</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">*</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">flag</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">continue</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span> <span class="o">+=</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">flag</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span>
                <span class="n">res</span><span class="o">--</span><span class="p">;</span>
                <span class="n">flag</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>Summary:</p>
<ol>
<li>'1' is not a prime.</li>
<li>This is called Sieve of Eratosthenes, so beautiful.</li>
<li>32ms, 98.1%</li>
</ol>
<h3><a href="https://leetcode.com/problems/isomorphic-strings/">205. Isomorphic Strings</a></h3>
<p>Given two strings s and t, determine if they are isomorphic.</p>
<p>Two strings are isomorphic if the characters in s can be replaced to get t.</p>
<p>All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.</p>
<ul>
<li>You may assume both s and t have the same length.</li>
</ul>
<p>Example:</p>
<ul>
<li>Given "egg", "add", return true.</li>
<li>Given "foo", "bar", return false.</li>
<li>Given "paper", "title", return true.</li>
</ul>
<p>C Solution:</p>
<div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">isIsomorphic</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">s</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">flag</span><span class="p">[</span><span class="mi">256</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">},</span> <span class="n">_flag</span><span class="p">[</span><span class="mi">245</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">flag</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">!=</span> <span class="n">_flag</span><span class="p">[</span><span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="n">flag</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">_flag</span><span class="p">[</span><span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>Summary:</p>
<ol>
<li>The solution is beautiful.</li>
<li>'i + 1' is required, in case 'aa' and 'ab'.</li>
<li>0ms, 64.71%</li>
<li>Same as following 290. Word Pattern</li>
</ol>
<h3><a href="https://leetcode.com/problems/contains-duplicate/">217. Contains Duplicate</a></h3>
<p>Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.</p>
<p>Solution:</p>
<div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">He</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">He</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">Ht</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">He</span> <span class="o">**</span><span class="n">list</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">Ht</span> <span class="o">*</span><span class="nf">create</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">Ht</span> <span class="o">*</span><span class="n">ht</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">Ht</span><span class="p">));</span>
    <span class="n">ht</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
    <span class="n">ht</span><span class="o">-&gt;</span><span class="n">list</span> <span class="o">=</span> <span class="n">calloc</span><span class="p">(</span><span class="n">ht</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">He</span> <span class="o">*</span><span class="p">));</span>
    <span class="k">return</span> <span class="n">ht</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="nf">find_or_insert</span><span class="p">(</span><span class="k">struct</span> <span class="n">Ht</span> <span class="o">*</span><span class="n">ht</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">ind</span> <span class="o">=</span> <span class="n">val</span> <span class="o">%</span> <span class="n">ht</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ind</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">ind</span> <span class="o">=</span> <span class="o">-</span><span class="n">ind</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">He</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">ht</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">[</span><span class="n">ind</span><span class="p">];</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">==</span> <span class="n">val</span><span class="p">)</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">He</span><span class="p">));</span>
    <span class="n">p</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
    <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">ht</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">[</span><span class="n">ind</span><span class="p">];</span>
    <span class="n">ht</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">bool</span> <span class="nf">containsDuplicate</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numsSize</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">Ht</span> <span class="o">*</span><span class="n">ht</span> <span class="o">=</span> <span class="n">create</span><span class="p">();</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numsSize</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">find_or_insert</span><span class="p">(</span><span class="n">ht</span><span class="p">,</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>Summary:</p>
<ol>
<li>This is what HashTable does. nothing to say.</li>
<li>39ms, 39.73%</li>
</ol>
<h3><a href="https://leetcode.com/problems/contains-duplicate-ii/">219. Contains Duplicate ||</a></h3>
<p>Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k.</p>
<p>C Solution:</p>
<div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">He</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">He</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">Ht</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">He</span> <span class="o">**</span><span class="n">list</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">Ht</span> <span class="o">*</span><span class="nf">create</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">Ht</span> <span class="o">*</span><span class="n">ht</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">Ht</span><span class="p">));</span>
    <span class="n">ht</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
    <span class="n">ht</span><span class="o">-&gt;</span><span class="n">list</span> <span class="o">=</span> <span class="n">calloc</span><span class="p">(</span><span class="n">ht</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">He</span> <span class="o">*</span><span class="p">));</span>
    <span class="k">return</span> <span class="n">ht</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="nf">find_or_insert</span><span class="p">(</span><span class="k">struct</span> <span class="n">Ht</span> <span class="o">*</span><span class="n">ht</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">ind</span> <span class="o">=</span> <span class="n">val</span> <span class="o">%</span> <span class="n">ht</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ind</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">ind</span> <span class="o">=</span> <span class="o">-</span><span class="n">ind</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">He</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">ht</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">[</span><span class="n">ind</span><span class="p">];</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">==</span> <span class="n">val</span><span class="p">)</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">He</span><span class="p">));</span>
    <span class="n">p</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
    <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">ht</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">[</span><span class="n">ind</span><span class="p">];</span>
    <span class="n">ht</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">delete</span><span class="p">(</span><span class="k">struct</span> <span class="n">Ht</span> <span class="o">*</span><span class="n">ht</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">ind</span> <span class="o">=</span> <span class="n">val</span> <span class="o">%</span> <span class="n">ht</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ind</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">ind</span> <span class="o">=</span> <span class="o">-</span><span class="n">ind</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">He</span> <span class="o">**</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">ht</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">[</span><span class="n">ind</span><span class="p">]);</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">==</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">struct</span> <span class="n">He</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="n">free</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">);</span>
            <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>   
        <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="nf">containsNearbyDuplicate</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numsSize</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">Ht</span> <span class="o">*</span><span class="n">ht</span> <span class="o">=</span> <span class="n">create</span><span class="p">();</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numsSize</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">find_or_insert</span><span class="p">(</span><span class="n">ht</span><span class="p">,</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">delete</span><span class="p">(</span><span class="n">ht</span><span class="p">,</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">k</span><span class="p">]);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>Summary:</p>
<ol>
<li>There are two ways, first is delete the old element, second is remember the index.</li>
<li>19ms, 70.97%</li>
</ol>
<h3><a href="https://leetcode.com/problems/valid-anagram/">242. Valid Anagram</a></h3>
<p>Given two strings s and t, write a function to determine if t is an anagram of s.</p>
<ul>
<li>You may assume the string contains only lowercase alphabets.</li>
<li>What if the inputs contain unicode characters? How would you adapt your solution to such case?<ul>
<li>use a real HashTable</li>
</ul>
</li>
</ul>
<p>Example:</p>
<ul>
<li>s = "anagram", t = "nagaram", return true.</li>
<li>s = "rat", t = "car", return false.</li>
</ul>
<p>C Solution:</p>
<div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">isAnagram</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">s</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">flag</span><span class="p">[</span><span class="mi">26</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="k">for</span> <span class="p">(;</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span> <span class="n">s</span><span class="o">++</span><span class="p">)</span> <span class="n">flag</span><span class="p">[</span><span class="o">*</span><span class="n">s</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(;</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span> <span class="n">t</span><span class="o">++</span><span class="p">)</span> <span class="n">flag</span><span class="p">[</span><span class="o">*</span><span class="n">t</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">26</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">flag</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">isAnagram</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">s</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">flag</span><span class="p">[</span><span class="mi">256</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">diff</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">continue</span><span class="p">;</span>
        <span class="n">diff</span> <span class="o">+=</span> <span class="o">++</span><span class="n">flag</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="n">diff</span> <span class="o">+=</span> <span class="o">--</span><span class="n">flag</span><span class="p">[</span><span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">||</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">?</span> <span class="nb">false</span> <span class="o">:</span> <span class="o">!</span><span class="n">diff</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>Summary:</p>
<ol>
<li>nothing special.</li>
<li>3ms, 37.59%</li>
<li>similar to 438. Find All Anagrams in a String.</li>
</ol>
<h3><a href="https://leetcode.com/problems/strobogrammatic-number/">246. Strobogrammatic Number</a></h3>
<p>A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).</p>
<p>Write a function to determine if a number is strobogrammatic. The number is represented as a string.</p>
<p>Example: </p>
<ul>
<li>the numbers "69", "88", and "818" are all strobogrammatic.</li>
</ul>
<p>C Solution:</p>
<div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">isStrobogrammatic</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">num</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">flag</span><span class="p">[</span><span class="mi">256</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="n">flag</span><span class="p">[</span><span class="sc">&#39;6&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;9&#39;</span><span class="p">;</span>
    <span class="n">flag</span><span class="p">[</span><span class="sc">&#39;9&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;6&#39;</span><span class="p">;</span>
    <span class="n">flag</span><span class="p">[</span><span class="sc">&#39;0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;0&#39;</span><span class="p">;</span>
    <span class="n">flag</span><span class="p">[</span><span class="sc">&#39;1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;1&#39;</span><span class="p">;</span>
    <span class="n">flag</span><span class="p">[</span><span class="sc">&#39;8&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;8&#39;</span><span class="p">;</span>

    <span class="kt">char</span> <span class="o">*</span><span class="n">l</span> <span class="o">=</span> <span class="n">num</span><span class="p">,</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="o">+</span> <span class="n">num</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(;</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="n">r</span> <span class="o">&amp;&amp;</span> <span class="n">flag</span><span class="p">[</span><span class="o">*</span><span class="n">l</span><span class="p">]</span> <span class="o">==</span> <span class="o">*</span><span class="n">r</span> <span class="o">&amp;&amp;</span> <span class="n">flag</span><span class="p">[</span><span class="o">*</span><span class="n">r</span><span class="p">]</span> <span class="o">==</span> <span class="o">*</span><span class="n">l</span><span class="p">;</span> <span class="n">l</span><span class="o">++</span><span class="p">,</span> <span class="n">r</span><span class="o">--</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">==</span> <span class="n">r</span> <span class="o">&amp;&amp;</span>  <span class="o">*</span><span class="n">l</span> <span class="o">!=</span> <span class="sc">&#39;0&#39;</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">l</span> <span class="o">!=</span> <span class="sc">&#39;1&#39;</span> <span class="o">&amp;&amp;</span>  <span class="o">*</span><span class="n">l</span> <span class="o">!=</span> <span class="sc">&#39;8&#39;</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>Summary:</p>
<ol>
<li>nothing special.</li>
<li>0ms, 0%.</li>
</ol>
<h3><a href="https://leetcode.com/problems/group-shifted-strings/">249. Group Shifted Strings</a></h3>
<p>Given a string, we can "shift" each of its letter to its successive letter, for example: "abc" -&gt; "bcd". We can keep "shifting" which forms the sequence:</p>
<ul>
<li>"abc" -&gt; "bcd" -&gt; ... -&gt; "xyz"</li>
</ul>
<p>Given a list of strings which contains only lowercase alphabets, group all strings that belong to the same shifting sequence.</p>
<p>Example: </p>
<ul>
<li>Given: ["abc", "bcd", "acef", "xyz", "az", "ba", "a", "z"], </li>
<li>A solution is: [ ["abc","bcd","xyz"], ["az","ba"], ["acef"], ["a","z"] ]</li>
</ul>
<p>C Solution:</p>
<div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">He</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">width</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">returnInd</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">He</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">Ht</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">He</span> <span class="o">**</span><span class="n">list</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">find_or_insert</span><span class="p">(</span><span class="k">struct</span> <span class="n">Ht</span> <span class="o">*</span><span class="n">ht</span><span class="p">,</span> <span class="kt">char</span> <span class="o">****</span><span class="n">res</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="o">**</span><span class="n">columnSizes</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">returnSize</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">width</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="n">ind</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">width</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">str</span><span class="p">[</span><span class="n">width</span><span class="p">];</span> <span class="n">width</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">str</span><span class="p">[</span><span class="n">width</span><span class="p">]</span> <span class="o">-</span> <span class="n">str</span><span class="p">[</span><span class="n">width</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">tmp</span> <span class="o">+=</span> <span class="mi">26</span><span class="p">;</span>
        <span class="n">ind</span> <span class="o">+=</span> <span class="n">tmp</span> <span class="o">*</span> <span class="n">t</span><span class="p">;</span>
        <span class="n">t</span> <span class="o">*=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">ind</span> <span class="o">=</span> <span class="n">ind</span> <span class="o">%</span> <span class="n">ht</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">He</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">ht</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">[</span><span class="n">ind</span><span class="p">];</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">width</span> <span class="o">==</span> <span class="n">width</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">str</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">str</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">tmp</span> <span class="o">+</span> <span class="mi">26</span> <span class="o">:</span> <span class="n">tmp</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">width</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="kt">int</span> <span class="n">dis</span> <span class="o">=</span> <span class="n">str</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">str</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
                <span class="n">dis</span> <span class="o">=</span> <span class="n">dis</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">dis</span> <span class="o">+</span> <span class="mi">26</span> <span class="o">:</span> <span class="n">dis</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">dis</span> <span class="o">!=</span> <span class="n">tmp</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">width</span><span class="p">)</span> <span class="p">{</span>
                <span class="p">(</span><span class="o">*</span><span class="n">columnSizes</span><span class="p">)[</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">returnInd</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
                <span class="p">(</span><span class="o">*</span><span class="n">res</span><span class="p">)[</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">returnInd</span><span class="p">]</span> <span class="o">=</span> <span class="n">realloc</span><span class="p">((</span><span class="o">*</span><span class="n">res</span><span class="p">)[</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">returnInd</span><span class="p">],</span> <span class="p">(</span><span class="o">*</span><span class="n">columnSizes</span><span class="p">)[</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">returnInd</span><span class="p">]</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">));</span>
                <span class="p">(</span><span class="o">*</span><span class="n">res</span><span class="p">)[</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">returnInd</span><span class="p">][(</span><span class="o">*</span><span class="n">columnSizes</span><span class="p">)[</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">returnInd</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">width</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
                <span class="n">memcpy</span><span class="p">((</span><span class="o">*</span><span class="n">res</span><span class="p">)[</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">returnInd</span><span class="p">][(</span><span class="o">*</span><span class="n">columnSizes</span><span class="p">)[</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">returnInd</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">str</span><span class="p">,</span> <span class="n">width</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
                <span class="k">return</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">He</span><span class="p">));</span>
    <span class="n">p</span><span class="o">-&gt;</span><span class="n">str</span> <span class="o">=</span> <span class="n">str</span><span class="p">;</span>
    <span class="n">p</span><span class="o">-&gt;</span><span class="n">width</span> <span class="o">=</span> <span class="n">width</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">size</span> <span class="o">==</span> <span class="o">*</span><span class="n">returnSize</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">*</span><span class="n">size</span> <span class="o">+=</span> <span class="mi">1000</span><span class="p">;</span>
        <span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="n">realloc</span><span class="p">(</span><span class="o">*</span><span class="n">res</span><span class="p">,</span> <span class="o">*</span><span class="n">size</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span> <span class="o">**</span><span class="p">));</span>
        <span class="o">*</span><span class="n">columnSizes</span> <span class="o">=</span> <span class="n">realloc</span><span class="p">(</span><span class="o">*</span><span class="n">columnSizes</span><span class="p">,</span> <span class="o">*</span><span class="n">size</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="p">(</span><span class="o">*</span><span class="n">res</span><span class="p">)[</span><span class="o">*</span><span class="n">returnSize</span><span class="p">]</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">));</span>
    <span class="p">(</span><span class="o">*</span><span class="n">res</span><span class="p">)[</span><span class="o">*</span><span class="n">returnSize</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">width</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">memcpy</span><span class="p">((</span><span class="o">*</span><span class="n">res</span><span class="p">)[</span><span class="o">*</span><span class="n">returnSize</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">str</span><span class="p">,</span> <span class="n">width</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">(</span><span class="o">*</span><span class="n">columnSizes</span><span class="p">)[</span><span class="o">*</span><span class="n">returnSize</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">p</span><span class="o">-&gt;</span><span class="n">returnInd</span> <span class="o">=</span> <span class="o">*</span><span class="n">returnSize</span><span class="p">;</span>
    <span class="o">++*</span><span class="n">returnSize</span><span class="p">;</span>
    <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">ht</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">[</span><span class="n">ind</span><span class="p">];</span>
    <span class="n">ht</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">char</span><span class="o">***</span> <span class="nf">groupStrings</span><span class="p">(</span><span class="kt">char</span><span class="o">**</span> <span class="n">strings</span><span class="p">,</span> <span class="kt">int</span> <span class="n">stringsSize</span><span class="p">,</span> <span class="kt">int</span><span class="o">**</span> <span class="n">columnSizes</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">returnSize</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
    <span class="o">*</span><span class="n">columnSizes</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">size</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
    <span class="kt">char</span> <span class="o">***</span><span class="n">res</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">size</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span> <span class="o">**</span><span class="p">));</span>
    <span class="o">*</span><span class="n">returnSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">Ht</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">*</span><span class="n">ht</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">;</span>
    <span class="n">ht</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
    <span class="n">ht</span><span class="o">-&gt;</span><span class="n">list</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">ht</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">He</span> <span class="o">*</span><span class="p">));</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">stringsSize</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">find_or_insert</span><span class="p">(</span><span class="n">ht</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">res</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">,</span> <span class="n">columnSizes</span><span class="p">,</span> <span class="n">returnSize</span><span class="p">,</span> <span class="n">strings</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>Summary:</p>
<ol>
<li>The logic behind is simple, but the code is troublesome.</li>
<li>First, we need the hash function.</li>
<li>Second, merge HashTable with the res.</li>
<li>0ms, 0%.</li>
</ol>
<h3><a href="https://leetcode.com/problems/palindrome-permutation/">266. Palindrome Permutation</a></h3>
<p>Given a string, determine if a permutation of the string could form a palindrome.</p>
<p>Example:</p>
<ul>
<li>"code" -&gt; False, "aab" -&gt; True, "carerac" -&gt; True.</li>
</ul>
<p>C Solution:</p>
<div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">canPermutePalindrome</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">flag</span><span class="p">[</span><span class="mi">256</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(;</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span> <span class="n">s</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">flag</span><span class="p">[</span><span class="o">*</span><span class="n">s</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">res</span><span class="o">--</span><span class="p">;</span>
            <span class="n">flag</span><span class="p">[</span><span class="o">*</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">res</span><span class="o">++</span><span class="p">;</span>
            <span class="n">flag</span><span class="p">[</span><span class="o">*</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">res</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>Summary:</p>
<ol>
<li>nothing special.</li>
<li>0ms, 0%</li>
</ol>
<h3><a href="https://leetcode.com/problems/unique-word-abbreviation/">288. Unique Word Abbreviation</a></h3>
<p>An abbreviation of a word follows the form <first letter><number><last letter>. Below are some examples of word abbreviations:</p>
<ul>
<li>it                      --&gt; it    (no abbreviation)</li>
<li>d|o|g                   --&gt; d1g</li>
<li>i|nternationalizatio|n  --&gt; i18n</li>
<li>l|ocalizatio|n          --&gt; l10n</li>
</ul>
<p>Assume you have a dictionary and given a word, find whether its abbreviation is unique in the dictionary. A word's abbreviation is unique if no other word from the dictionary has the same abbreviation.</p>
<p>Example: </p>
<ul>
<li>Given dictionary = [ "deer", "door", "cake", "card" ]</li>
<li>isUnique("dear") -&gt; false</li>
<li>isUnique("cart") -&gt; true</li>
<li>isUnique("cane") -&gt; false</li>
<li>isUnique("make") -&gt; true</li>
</ul>
<p>C Solution:</p>
<div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">He</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">start</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">middle</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">end</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">multi</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">He</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ValidWordAbbr</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">He</span> <span class="o">**</span><span class="n">list</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ValidWordAbbr</span><span class="o">*</span> <span class="nf">ValidWordAbbrCreate</span><span class="p">(</span><span class="kt">char</span><span class="o">**</span> <span class="n">dictionary</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dictionarySize</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">ValidWordAbbr</span> <span class="o">*</span><span class="n">vwa</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ValidWordAbbr</span><span class="p">));</span>
    <span class="n">vwa</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
    <span class="n">vwa</span><span class="o">-&gt;</span><span class="n">list</span> <span class="o">=</span> <span class="n">calloc</span><span class="p">(</span><span class="n">vwa</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">He</span> <span class="o">*</span><span class="p">));</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dictionarySize</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">dictionary</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="kt">char</span> <span class="n">start</span> <span class="o">=</span> <span class="n">dictionary</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
        <span class="kt">char</span> <span class="n">end</span> <span class="o">=</span> <span class="n">dictionary</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
        <span class="n">len</span> <span class="o">-=</span> <span class="mi">2</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="n">ind</span> <span class="o">=</span> <span class="n">start</span> <span class="o">*</span> <span class="mi">321</span> <span class="o">+</span> <span class="n">len</span> <span class="o">*</span> <span class="mi">21</span> <span class="o">+</span> <span class="n">end</span><span class="p">;</span>
        <span class="n">ind</span> <span class="o">%=</span> <span class="n">vwa</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">He</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">vwa</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">[</span><span class="n">ind</span><span class="p">];</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">==</span> <span class="n">start</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">==</span> <span class="n">end</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">middle</span> <span class="o">==</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">multi</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">dictionary</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">str</span><span class="p">))</span> <span class="p">{</span>
                    <span class="n">p</span><span class="o">-&gt;</span><span class="n">multi</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span> 
            <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">He</span><span class="p">));</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">middle</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">multi</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">str</span> <span class="o">=</span> <span class="n">dictionary</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">vwa</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">[</span><span class="n">ind</span><span class="p">];</span>
        <span class="n">vwa</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">vwa</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="nf">isUnique</span><span class="p">(</span><span class="k">struct</span> <span class="n">ValidWordAbbr</span><span class="o">*</span> <span class="n">vwa</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">word</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">word</span><span class="p">);</span>
    <span class="kt">char</span> <span class="n">start</span> <span class="o">=</span> <span class="n">word</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="kt">char</span> <span class="n">end</span> <span class="o">=</span> <span class="n">word</span><span class="p">[</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
    <span class="n">len</span> <span class="o">-=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="n">ind</span> <span class="o">=</span> <span class="n">start</span> <span class="o">*</span> <span class="mi">321</span> <span class="o">+</span> <span class="n">len</span> <span class="o">*</span> <span class="mi">21</span> <span class="o">+</span> <span class="n">end</span><span class="p">;</span>
    <span class="n">ind</span> <span class="o">%=</span> <span class="n">vwa</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">He</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">vwa</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">[</span><span class="n">ind</span><span class="p">];</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">==</span> <span class="n">start</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">==</span> <span class="n">end</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">middle</span> <span class="o">==</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">multi</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">str</span><span class="p">))</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ValidWordAbbrFree</span><span class="p">(</span><span class="k">struct</span> <span class="n">ValidWordAbbr</span><span class="o">*</span> <span class="n">vwa</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">vwa</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">He</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">vwa</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">q</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="n">free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">q</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">free</span><span class="p">(</span><span class="n">vwa</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">vwa</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>Summary:</p>
<ol>
<li>If 'd1g' only contains 'dog', then isunique('dog') return true and isunique('dtg') return false.</li>
<li>Using C to solve problems related to HashTable and string is painful.</li>
<li>49ms, 100% (depend on hash function and hashtable size)</li>
</ol>
<h3><a href="https://leetcode.com/problems/word-pattern/">290. Word Pattern</a></h3>
<p>Given a pattern and a string str, find if str follows the same pattern.</p>
<p>Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in str.</p>
<ul>
<li>You may assume pattern contains only lowercase letters, and str contains lowercase letters separated by a single space.</li>
</ul>
<p>Examples:</p>
<ul>
<li>pattern = "abba", str = "dog cat cat dog" should return true.</li>
<li>pattern = "abba", str = "dog cat cat fish" should return false.</li>
<li>pattern = "aaaa", str = "dog cat cat dog" should return false.</li>
<li>pattern = "abba", str = "dog dog dog dog" should return false.</li>
</ul>
<p>C Solution:</p>
<div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">isequal</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">struct</span> <span class="n">He</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">He</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">Ht</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">He</span> <span class="o">**</span><span class="n">list</span><span class="p">;</span> 
<span class="p">};</span>
<span class="kt">bool</span> <span class="nf">find</span><span class="p">(</span><span class="k">struct</span> <span class="n">Ht</span> <span class="o">*</span><span class="n">ht</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="n">ind</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ind</span> <span class="o">+=</span> <span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">t</span><span class="p">;</span>
        <span class="n">t</span> <span class="o">*=</span> <span class="mi">26</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">ind</span> <span class="o">%=</span> <span class="n">ht</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>

    <span class="k">struct</span> <span class="n">He</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">ht</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">[</span><span class="n">ind</span><span class="p">];</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">==</span> <span class="n">len</span> <span class="o">&amp;&amp;</span> <span class="n">isequal</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">str</span><span class="p">,</span> <span class="n">str</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="k">struct</span> <span class="n">Ht</span> <span class="o">*</span><span class="n">ht</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="n">ind</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ind</span> <span class="o">+=</span> <span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">t</span><span class="p">;</span>
        <span class="n">t</span> <span class="o">*=</span> <span class="mi">26</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">ind</span> <span class="o">%=</span> <span class="n">ht</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>

    <span class="k">struct</span> <span class="n">He</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">He</span><span class="p">));</span>
    <span class="n">p</span><span class="o">-&gt;</span><span class="n">str</span> <span class="o">=</span> <span class="n">str</span><span class="p">;</span>
    <span class="n">p</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
    <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">ht</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">[</span><span class="n">ind</span><span class="p">];</span>
    <span class="n">ht</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">bool</span> <span class="nf">wordPattern</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">pattern</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">ctos</span><span class="p">[</span><span class="mi">26</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">ctosLen</span><span class="p">[</span><span class="mi">26</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="k">struct</span> <span class="n">Ht</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">*</span><span class="n">ht</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">;</span>
    <span class="n">ht</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
    <span class="n">ht</span><span class="o">-&gt;</span><span class="n">list</span> <span class="o">=</span> <span class="n">calloc</span><span class="p">(</span><span class="n">ht</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">He</span> <span class="o">*</span><span class="p">));</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(;</span> <span class="o">*</span><span class="n">pattern</span><span class="p">;</span> <span class="n">pattern</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">str</span><span class="p">;</span> <span class="o">*</span><span class="n">p</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">p</span> <span class="o">!=</span> <span class="sc">&#39; &#39;</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ctos</span><span class="p">[</span><span class="o">*</span><span class="n">pattern</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">isequal</span><span class="p">(</span><span class="n">ctos</span><span class="p">[</span><span class="o">*</span><span class="n">pattern</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span><span class="p">],</span> <span class="n">str</span><span class="p">,</span> <span class="n">p</span> <span class="o">-</span> <span class="n">str</span><span class="p">))</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ctos</span><span class="p">[</span><span class="o">*</span><span class="n">pattern</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span><span class="p">])</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">find</span><span class="p">(</span><span class="n">ht</span><span class="p">,</span> <span class="n">str</span><span class="p">,</span> <span class="n">p</span> <span class="o">-</span> <span class="n">str</span><span class="p">))</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
            <span class="n">ctos</span><span class="p">[</span><span class="o">*</span><span class="n">pattern</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">str</span><span class="p">;</span>
            <span class="n">ctosLen</span><span class="p">[</span><span class="o">*</span><span class="n">pattern</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span> <span class="o">-</span> <span class="n">str</span><span class="p">;</span>
            <span class="n">insert</span><span class="p">(</span><span class="n">ht</span><span class="p">,</span> <span class="n">str</span><span class="p">,</span> <span class="n">p</span> <span class="o">-</span> <span class="n">str</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">pattern</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">str</span> <span class="o">=</span> <span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">str</span><span class="p">)</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>Summary:</p>
<ol>
<li>Using C to solve problems related to HashTable and string is painful.</li>
<li>What this problem need is a dictionary and a set.</li>
<li>Fortunately, array could perform the dictionary, so I only need to implement a set HashTable.</li>
<li>0ms, 6.67%</li>
<li>If I use python or java or c++ to solve the problem, I could split str first and then use two dictionary to compare. The code could be concise, but not as efficient as c solution.</li>
<li>Same as the above problem 205. Isomorphic Strings.</li>
</ol>
<h3><a href="https://leetcode.com/problems/bulls-and-cows/">299. Bulls and Cows</a></h3>
<p>You are playing the following Bulls and Cows game with your friend: You write down a number and ask your friend to guess what the number is. 
Each time your friend makes a guess, you provide a hint that indicates how many digits in said guess match your secret number exactly in both digit and position (called "bulls") and how many digits match the secret number but locate in the wrong position (called "cows"). 
Your friend will use successive guesses and hints to eventually derive the secret number.</p>
<ul>
<li>You may assume that the secret number and your friend's guess only contain digits, and their lengths are always equal.</li>
</ul>
<p>Example:</p>
<ul>
<li>Secret number:  "1807", Friend's guess: "7810"</li>
<li>Hint: 1 bull and 3 cows. (The bull is 8, the cows are 0, 1 and 7.)</li>
</ul>
<p>Write a function to return a hint according to the secret number and friend's guess, use A to indicate the bulls and B to indicate the cows. In the above example, your function should return "1A3B".</p>
<p>Please note that both secret number and friend's guess may contain duplicate digits, for example:</p>
<ul>
<li>Secret number:  "1123", Friend's guess: "0111"</li>
<li>In this case, the 1st 1 in friend's guess is a bull, the 2nd or 3rd 1 is a cow, and your function should return "1A1B".</li>
</ul>
<p>C Solution:</p>
<div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">save</span><span class="p">(</span><span class="kt">char</span> <span class="o">**</span><span class="n">res</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span><span class="o">*</span><span class="n">res</span><span class="p">)[(</span><span class="o">*</span><span class="n">len</span><span class="p">)</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;0&#39;</span><span class="p">;</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">len</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="o">*</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
            <span class="o">*</span><span class="n">size</span> <span class="o">+=</span> <span class="mi">1000</span><span class="p">;</span>
            <span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="n">realloc</span><span class="p">(</span><span class="o">*</span><span class="n">res</span><span class="p">,</span> <span class="o">*</span><span class="n">size</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="p">(</span><span class="o">*</span><span class="n">res</span><span class="p">)[</span><span class="o">*</span><span class="n">len</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span> <span class="o">%</span> <span class="mi">10</span> <span class="o">+</span> <span class="sc">&#39;0&#39;</span><span class="p">;</span>
        <span class="o">++*</span><span class="n">len</span><span class="p">;</span>
        <span class="n">val</span> <span class="o">/=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">reverse</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">l</span><span class="p">,</span> <span class="o">*</span><span class="n">r</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">l</span> <span class="o">=</span> <span class="n">res</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">res</span> <span class="o">+</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">;</span> <span class="n">l</span><span class="o">++</span><span class="p">,</span> <span class="n">r</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="o">*</span><span class="n">l</span><span class="p">;</span>
        <span class="o">*</span><span class="n">l</span> <span class="o">=</span> <span class="o">*</span><span class="n">r</span><span class="p">;</span>
        <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kt">char</span><span class="o">*</span> <span class="nf">getHint</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">secret</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">guess</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">bulls</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cows</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">flag</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">secret</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">secret</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">guess</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">bulls</span><span class="o">++</span><span class="p">;</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">flag</span><span class="p">[</span><span class="n">secret</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">cows</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">flag</span><span class="p">[</span><span class="n">secret</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">flag</span><span class="p">[</span><span class="n">guess</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span><span class="p">]</span> <span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">cows</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">flag</span><span class="p">[</span><span class="n">guess</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">res</span><span class="p">[</span><span class="n">len</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;B&#39;</span><span class="p">;</span>
    <span class="n">save</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">,</span> <span class="n">cows</span><span class="p">);</span>
    <span class="n">res</span><span class="p">[</span><span class="n">len</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;A&#39;</span><span class="p">;</span>
    <span class="n">save</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">,</span> <span class="n">bulls</span><span class="p">);</span>
    <span class="n">reverse</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
    <span class="n">res</span><span class="p">[</span><span class="n">len</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>Summary:</p>
<ol>
<li>0ms, 17.24%</li>
<li>The idea is beautiful.</li>
</ol>
<h3><a href="https://leetcode.com/problems/intersection-of-two-arrays/">349. Intersection of Two Arrays</a></h3>
<p>Given two arrays, write a function to compute their intersection.</p>
<ul>
<li>Each element in the result must be unique.</li>
<li>The result can be in any order.</li>
</ul>
<p>Example:</p>
<ul>
<li>Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2].</li>
</ul>
<p>C Solution:</p>
<div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">HE</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">HE</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">HT</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">HE</span> <span class="o">**</span><span class="n">list</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">HT</span> <span class="o">*</span><span class="nf">createHT</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">HT</span> <span class="o">*</span><span class="n">ht</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">HT</span><span class="p">));</span>
    <span class="n">ht</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
    <span class="n">ht</span><span class="o">-&gt;</span><span class="n">list</span> <span class="o">=</span> <span class="n">calloc</span><span class="p">(</span><span class="n">ht</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">HE</span> <span class="o">*</span><span class="p">));</span>
    <span class="k">return</span> <span class="n">ht</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">insertHT</span><span class="p">(</span><span class="k">struct</span> <span class="n">HT</span> <span class="o">*</span><span class="n">ht</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">ind</span> <span class="o">=</span> <span class="n">val</span> <span class="o">%</span> <span class="n">ht</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">HE</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">ht</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">[</span><span class="n">ind</span><span class="p">];</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">==</span> <span class="n">val</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        <span class="k">else</span> <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">struct</span> <span class="n">HE</span> <span class="o">*</span><span class="n">he</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">HE</span><span class="p">));</span>
    <span class="n">he</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
    <span class="n">he</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">ht</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">[</span><span class="n">ind</span><span class="p">];</span>
    <span class="n">ht</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">he</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">bool</span> <span class="nf">findHT</span><span class="p">(</span><span class="k">struct</span> <span class="n">HT</span> <span class="o">*</span><span class="n">ht</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">ind</span> <span class="o">=</span> <span class="n">val</span> <span class="o">%</span> <span class="n">ht</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">HE</span> <span class="o">**</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">ht</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">[</span><span class="n">ind</span><span class="p">]);</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">==</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">struct</span> <span class="n">HE</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="n">free</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">);</span>
            <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">save</span><span class="p">(</span><span class="kt">int</span> <span class="o">**</span><span class="n">res</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">returnSize</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">size</span> <span class="o">==</span> <span class="o">*</span><span class="n">returnSize</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">*</span><span class="n">size</span> <span class="o">+=</span> <span class="mi">1000</span><span class="p">;</span>
        <span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="n">realloc</span><span class="p">(</span><span class="o">*</span><span class="n">res</span><span class="p">,</span> <span class="o">*</span><span class="n">size</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="p">(</span><span class="o">*</span><span class="n">res</span><span class="p">)[(</span><span class="o">*</span><span class="n">returnSize</span><span class="p">)</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span><span class="o">*</span> <span class="nf">intersection</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">nums1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nums1Size</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">nums2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nums2Size</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">returnSize</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">nums1Size</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">nums2Size</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">shorter</span><span class="p">,</span> <span class="o">*</span><span class="n">longer</span><span class="p">,</span> <span class="n">ssize</span><span class="p">,</span> <span class="n">lsize</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">nums1Size</span> <span class="o">&lt;</span> <span class="n">nums2Size</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">shorter</span> <span class="o">=</span> <span class="n">nums1</span><span class="p">;</span>
        <span class="n">longer</span> <span class="o">=</span> <span class="n">nums2</span><span class="p">;</span>
        <span class="n">ssize</span> <span class="o">=</span> <span class="n">nums1Size</span><span class="p">;</span>
        <span class="n">lsize</span> <span class="o">=</span> <span class="n">nums2Size</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">shorter</span> <span class="o">=</span> <span class="n">nums2</span><span class="p">;</span>
        <span class="n">longer</span> <span class="o">=</span> <span class="n">nums1</span><span class="p">;</span>
        <span class="n">ssize</span> <span class="o">=</span> <span class="n">nums2Size</span><span class="p">;</span>
        <span class="n">lsize</span> <span class="o">=</span> <span class="n">nums1Size</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">ssize</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
    <span class="o">*</span><span class="n">returnSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">HT</span> <span class="o">*</span><span class="n">ht</span> <span class="o">=</span> <span class="n">createHT</span><span class="p">();</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ssize</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">insertHT</span><span class="p">(</span><span class="n">ht</span><span class="p">,</span> <span class="n">shorter</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">lsize</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">findHT</span><span class="p">(</span><span class="n">ht</span><span class="p">,</span> <span class="n">longer</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="p">{</span>
            <span class="n">save</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">,</span> <span class="n">returnSize</span><span class="p">,</span> <span class="n">longer</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>Summary:</p>
<ol>
<li>3ms, 35.79%</li>
<li>Hash the shorter array, maybe useful, maybe not.</li>
<li>Delete during checking the longer array.</li>
</ol>
<h3><a href="https://leetcode.com/problems/intersection-of-two-arrays-ii/">350. Intersection of Two Arrays II</a></h3>
<p>Given two arrays, write a function to compute their intersection.</p>
<ul>
<li>Each element in the result should appear as many times as it shows in both arrays.</li>
<li>The result can be in any order.</li>
</ul>
<p>Example:</p>
<ul>
<li>Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2].</li>
</ul>
<p>Follow up:</p>
<ul>
<li>What if the given array is already sorted? How would you optimize your algorithm?</li>
<li>What if nums1's size is small compared to nums2's size? Which algorithm is better?</li>
<li>What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?</li>
</ul>
<p>C Solution:</p>
<div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">HE</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">HE</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">HT</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">HE</span> <span class="o">**</span><span class="n">list</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">HT</span> <span class="o">*</span><span class="nf">createHT</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">HT</span> <span class="o">*</span><span class="n">ht</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">HT</span><span class="p">));</span>
    <span class="n">ht</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
    <span class="n">ht</span><span class="o">-&gt;</span><span class="n">list</span> <span class="o">=</span> <span class="n">calloc</span><span class="p">(</span><span class="n">ht</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">HE</span> <span class="o">*</span><span class="p">));</span>
    <span class="k">return</span> <span class="n">ht</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">insertHT</span><span class="p">(</span><span class="k">struct</span> <span class="n">HT</span> <span class="o">*</span><span class="n">ht</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">ind</span> <span class="o">=</span> <span class="n">val</span> <span class="o">%</span> <span class="n">ht</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">HE</span> <span class="o">*</span><span class="n">he</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">HE</span><span class="p">));</span>
    <span class="n">he</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
    <span class="n">he</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">ht</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">[</span><span class="n">ind</span><span class="p">];</span>
    <span class="n">ht</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">he</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">bool</span> <span class="nf">findHT</span><span class="p">(</span><span class="k">struct</span> <span class="n">HT</span> <span class="o">*</span><span class="n">ht</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">ind</span> <span class="o">=</span> <span class="n">val</span> <span class="o">%</span> <span class="n">ht</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">HE</span> <span class="o">**</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">ht</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">[</span><span class="n">ind</span><span class="p">]);</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">==</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">struct</span> <span class="n">HE</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="n">free</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">);</span>
            <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">save</span><span class="p">(</span><span class="kt">int</span> <span class="o">**</span><span class="n">res</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">returnSize</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">size</span> <span class="o">==</span> <span class="o">*</span><span class="n">returnSize</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">*</span><span class="n">size</span> <span class="o">+=</span> <span class="mi">1000</span><span class="p">;</span>
        <span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="n">realloc</span><span class="p">(</span><span class="o">*</span><span class="n">res</span><span class="p">,</span> <span class="o">*</span><span class="n">size</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="p">(</span><span class="o">*</span><span class="n">res</span><span class="p">)[(</span><span class="o">*</span><span class="n">returnSize</span><span class="p">)</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span><span class="o">*</span> <span class="nf">intersect</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">nums1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nums1Size</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">nums2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nums2Size</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">returnSize</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">nums1Size</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">nums2Size</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">shorter</span><span class="p">,</span> <span class="o">*</span><span class="n">longer</span><span class="p">,</span> <span class="n">ssize</span><span class="p">,</span> <span class="n">lsize</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">nums1Size</span> <span class="o">&lt;</span> <span class="n">nums2Size</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">shorter</span> <span class="o">=</span> <span class="n">nums1</span><span class="p">;</span>
        <span class="n">longer</span> <span class="o">=</span> <span class="n">nums2</span><span class="p">;</span>
        <span class="n">ssize</span> <span class="o">=</span> <span class="n">nums1Size</span><span class="p">;</span>
        <span class="n">lsize</span> <span class="o">=</span> <span class="n">nums2Size</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">shorter</span> <span class="o">=</span> <span class="n">nums2</span><span class="p">;</span>
        <span class="n">longer</span> <span class="o">=</span> <span class="n">nums1</span><span class="p">;</span>
        <span class="n">ssize</span> <span class="o">=</span> <span class="n">nums2Size</span><span class="p">;</span>
        <span class="n">lsize</span> <span class="o">=</span> <span class="n">nums1Size</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">size</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
    <span class="o">*</span><span class="n">returnSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">HT</span> <span class="o">*</span><span class="n">ht</span> <span class="o">=</span> <span class="n">createHT</span><span class="p">();</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ssize</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">insertHT</span><span class="p">(</span><span class="n">ht</span><span class="p">,</span> <span class="n">shorter</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">lsize</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">findHT</span><span class="p">(</span><span class="n">ht</span><span class="p">,</span> <span class="n">longer</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="p">{</span>
            <span class="n">save</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">,</span> <span class="n">returnSize</span><span class="p">,</span> <span class="n">longer</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>Summary: </p>
<ol>
<li>3ms, 45.45%</li>
<li>Quite similar to the privious problem.</li>
<li>nothing special.</li>
</ol>
<h3><a href="https://leetcode.com/problems/logger-rate-limiter/">359. Logger Rate Limiter</a></h3>
<p>Design a logger system that receive stream of messages along with its timestamps, each message should be printed if and only if it is not printed in the last 10 seconds.</p>
<p>Given a message and a timestamp (in seconds granularity), return true if the message should be printed in the given timestamp, otherwise returns false.</p>
<p>It is possible that several messages arrive roughly at the same time.</p>
<p>Example:</p>
<div class="highlight"><pre><span></span><span class="n">Logger</span> <span class="n">logger</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Logger</span><span class="p">();</span>
<span class="c1">// logging string &quot;foo&quot; at timestamp 1</span>
<span class="n">logger</span><span class="p">.</span><span class="n">shouldPrintMessage</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;foo&quot;</span><span class="p">);</span> <span class="n">returns</span> <span class="nb">true</span><span class="p">;</span> 
<span class="c1">// logging string &quot;bar&quot; at timestamp 2</span>
<span class="n">logger</span><span class="p">.</span><span class="n">shouldPrintMessage</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="s">&quot;bar&quot;</span><span class="p">);</span> <span class="n">returns</span> <span class="nb">true</span><span class="p">;</span>
<span class="c1">// logging string &quot;foo&quot; at timestamp 3</span>
<span class="n">logger</span><span class="p">.</span><span class="n">shouldPrintMessage</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="s">&quot;foo&quot;</span><span class="p">);</span> <span class="n">returns</span> <span class="nb">false</span><span class="p">;</span>
<span class="c1">// logging string &quot;bar&quot; at timestamp 8</span>
<span class="n">logger</span><span class="p">.</span><span class="n">shouldPrintMessage</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="s">&quot;bar&quot;</span><span class="p">);</span> <span class="n">returns</span> <span class="nb">false</span><span class="p">;</span>
<span class="c1">// logging string &quot;foo&quot; at timestamp 10</span>
<span class="n">logger</span><span class="p">.</span><span class="n">shouldPrintMessage</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="s">&quot;foo&quot;</span><span class="p">);</span> <span class="n">returns</span> <span class="nb">false</span><span class="p">;</span>
<span class="c1">// logging string &quot;foo&quot; at timestamp 11</span>
<span class="n">logger</span><span class="p">.</span><span class="n">shouldPrintMessage</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span><span class="s">&quot;foo&quot;</span><span class="p">);</span> <span class="n">returns</span> <span class="nb">true</span><span class="p">;</span>
</pre></div>


<p>Python Solution:</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Logger</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize your data structure here.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">{}</span>


    <span class="k">def</span> <span class="nf">shouldPrintMessage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns true if the message should be printed in the given timestamp, otherwise returns false.</span>
<span class="sd">        If this method returns false, the message will not be printed.</span>
<span class="sd">        The timestamp is in seconds granularity.</span>
<span class="sd">        :type timestamp: int</span>
<span class="sd">        :type message: str</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">message</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="ow">and</span> <span class="n">timestamp</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">message</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span> <span class="k">return</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">message</span><span class="p">]</span> <span class="o">=</span> <span class="n">timestamp</span>
        <span class="k">return</span> <span class="bp">True</span>



<span class="c1"># Your Logger object will be instantiated and called as such:</span>
<span class="c1"># obj = Logger()</span>
<span class="c1"># param_1 = obj.shouldPrintMessage(timestamp,message)</span>
</pre></div>


<p>Summary:</p>
<ol>
<li>C Solution can't pass the testset, I have no idea why.</li>
<li>nothing special.</li>
<li>149ms, 88.70%</li>
</ol>
<h3><a href="https://leetcode.com/problems/find-the-difference/">389. Find the Difference</a></h3>
<p>Given two strings s and t which consist of only lowercase letters.</p>
<p>String t is generated by random shuffling string s and then add one more letter at a random position.</p>
<p>Find the letter that was added in t.</p>
<p>Example:</p>
<ul>
<li>Input: s = "abcd" t = "abcde"</li>
<li>Output: e</li>
<li>Explanation: 'e' is the letter that was added.</li>
</ul>
<p>Common solution:</p>
<div class="highlight"><pre><span></span><span class="kt">char</span> <span class="nf">findTheDifference</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">s</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">ht</span><span class="p">[</span><span class="mi">26</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="n">ht</span><span class="p">[</span><span class="o">*</span><span class="n">p</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="n">ht</span><span class="p">[</span><span class="o">*</span><span class="n">p</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">26</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ht</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="n">i</span><span class="o">++</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">i</span> <span class="o">+</span> <span class="sc">&#39;a&#39;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>Using a 32 bits unsigned integer instead of the array.</p>
<div class="highlight"><pre><span></span><span class="kt">char</span> <span class="nf">findTheDifference</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">s</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">ht</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">flag</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="n">ht</span> <span class="o">^=</span> <span class="n">flag</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="n">ht</span> <span class="o">^=</span> <span class="n">flag</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span><span class="p">);</span>
    <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="sc">&#39;a&#39;</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">ht</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="n">c</span><span class="o">++</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">c</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>Bit manipulation (but not a technique of hash table):</p>
<div class="highlight"><pre><span></span><span class="kt">char</span> <span class="nf">findTheDifference</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">s</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(;</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span> <span class="n">s</span><span class="o">++</span><span class="p">)</span> <span class="n">c</span> <span class="o">^=</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(;</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span> <span class="n">t</span><span class="o">++</span><span class="p">)</span> <span class="n">c</span> <span class="o">^=</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">c</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>Summary:</p>
<ol>
<li>0ms, 14.02%</li>
<li>This problem should be solved with bit manipulation, so not a typical HashTable problem.</li>
<li>Same to above problem: 136. Single Number</li>
</ol>
<h3><a href="https://leetcode.com/problems/longest-palindrome/">409. Longest Palindrome</a></h3>
<p>Given a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters.</p>
<ul>
<li>This is case sensitive, for example "Aa" is not considered a palindrome here.</li>
<li>Assume the length of given string will not exceed 1,010.</li>
</ul>
<p>Example:</p>
<ul>
<li>Input: "abccccdd"</li>
<li>Output: 7</li>
<li>Explanation: One longest palindrome that can be built is "dccaccd", whose length is 7.</li>
</ul>
<p>Solutions:</p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">longestPalindrome</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">ht</span><span class="p">[</span><span class="mi">256</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">},</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ht</span><span class="p">[</span><span class="o">*</span><span class="n">p</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">res</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
            <span class="n">ht</span><span class="p">[</span><span class="o">*</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="n">ht</span><span class="p">[</span><span class="o">*</span><span class="n">p</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span> 
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">256</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ht</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">res</span><span class="o">++</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">longestPalindrome</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">flag</span><span class="p">[</span><span class="mi">256</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">},</span> <span class="n">odd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(;</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span> <span class="n">s</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">flag</span><span class="p">[</span><span class="o">*</span><span class="n">s</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">odd</span><span class="o">--</span><span class="p">;</span>
            <span class="n">flag</span><span class="p">[</span><span class="o">*</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="n">res</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">flag</span><span class="p">[</span><span class="o">*</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">odd</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">res</span> <span class="o">+</span> <span class="o">!!</span><span class="n">odd</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>Summary:</p>
<ol>
<li>Nothing special, just count.</li>
<li>0ms, 20%</li>
</ol>
<h3><a href="https://leetcode.com/problems/find-all-anagrams-in-a-string/">438. Find All Anagrams in a String</a></h3>
<p>Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.</p>
<ul>
<li>Strings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100.</li>
<li>The order of output does not matter.</li>
</ul>
<p>Example </p>
<ul>
<li>Input: s: "cbaebabacd" p: "abc"</li>
<li>Output: [0, 6]</li>
<li>Explanation:<ul>
<li>The substring with start index = 0 is "cba", which is an anagram of "abc".</li>
<li>The substring with start index = 6 is "bac", which is an anagram of "abc".</li>
</ul>
</li>
<li>Input: s: "abab" p: "ab"</li>
<li>Output: [0, 1, 2]</li>
<li>Explanation:<ul>
<li>The substring with start index = 0 is "ab", which is an anagram of "ab".</li>
<li>The substring with start index = 1 is "ba", which is an anagram of "ab".</li>
<li>The substring with start index = 2 is "ab", which is an anagram of "ab".</li>
</ul>
</li>
</ul>
<p>C Solution:</p>
<div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * Return an array of size *returnSize.</span>
<span class="cm"> * Note: The returned array must be malloced, assume caller calls free().</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">save</span><span class="p">(</span><span class="kt">int</span> <span class="o">**</span><span class="n">res</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">returnSize</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">size</span> <span class="o">==</span> <span class="o">*</span><span class="n">returnSize</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">*</span><span class="n">size</span> <span class="o">+=</span> <span class="mi">1000</span><span class="p">;</span>
        <span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="n">realloc</span><span class="p">(</span><span class="o">*</span><span class="n">res</span><span class="p">,</span> <span class="o">*</span><span class="n">size</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="p">(</span><span class="o">*</span><span class="n">res</span><span class="p">)[(</span><span class="o">*</span><span class="n">returnSize</span><span class="p">)</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span><span class="o">*</span> <span class="nf">findAnagrams</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">s</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">returnSize</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">strlen</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">size</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
    <span class="o">*</span><span class="n">returnSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">diff</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">flag</span><span class="p">[</span><span class="mi">256</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">continue</span><span class="p">;</span>
        <span class="n">diff</span> <span class="o">+=</span> <span class="o">++</span><span class="n">flag</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="n">diff</span> <span class="o">+=</span> <span class="o">--</span><span class="n">flag</span><span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">diff</span><span class="p">)</span> <span class="n">save</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">,</span> <span class="n">returnSize</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">];</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">diff</span> <span class="o">+=</span> <span class="o">++</span><span class="n">flag</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="n">diff</span> <span class="o">+=</span> <span class="o">--</span><span class="n">flag</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="n">i</span><span class="p">]]</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">diff</span><span class="p">)</span> <span class="n">save</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">,</span> <span class="n">returnSize</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>Summary:</p>
<ol>
<li>16ms, 76.74%</li>
<li>Maybe anagram problems can all use this idea: use a diff, one direction for add, the other for del.</li>
<li>Similar to 242. Valid Anagram</li>
</ol>
<h3><a href="https://leetcode.com/problems/number-of-boomerangs/">447. Number of Boomerangs</a></h3>
<p>Given n points in the plane that are all pairwise distinct, a "boomerang" is a tuple of points (i, j, k) such that the distance between i and j equals the distance between i and k (the order of the tuple matters).</p>
<p>Find the number of boomerangs. You may assume that n will be at most 500 and coordinates of points are all in the range [-10000, 10000] (inclusive).</p>
<p>Example:</p>
<ul>
<li>Input: [[0,0],[1,0],[2,0]]</li>
<li>Output: 2</li>
<li>Explanation: The two boomerangs are [[1,0],[0,0],[2,0]] and [[1,0],[2,0],[0,0]]</li>
</ul>
<p>C Solution:</p>
<div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">He</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">dist</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">He</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">Ht</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">He</span> <span class="o">**</span><span class="n">list</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">Ht</span> <span class="o">*</span><span class="nf">create</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">Ht</span> <span class="o">*</span><span class="n">ht</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">Ht</span><span class="p">));</span>
    <span class="n">ht</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
    <span class="n">ht</span><span class="o">-&gt;</span><span class="n">list</span> <span class="o">=</span> <span class="n">calloc</span><span class="p">(</span><span class="n">ht</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">He</span> <span class="o">*</span><span class="p">));</span>
    <span class="k">return</span> <span class="n">ht</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="k">struct</span> <span class="n">Ht</span> <span class="o">*</span><span class="n">ht</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dist</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">ind</span> <span class="o">=</span> <span class="n">dist</span> <span class="o">%</span> <span class="n">ht</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">He</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">ht</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">[</span><span class="n">ind</span><span class="p">];</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">dist</span> <span class="o">==</span> <span class="n">dist</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">p</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">++</span><span class="p">;</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">He</span><span class="p">));</span>
    <span class="n">p</span><span class="o">-&gt;</span><span class="n">dist</span> <span class="o">=</span> <span class="n">dist</span><span class="p">;</span>
    <span class="n">p</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">ht</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">[</span><span class="n">ind</span><span class="p">];</span>
    <span class="n">ht</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">numberOfBoomerangs</span><span class="p">(</span><span class="kt">int</span><span class="o">**</span> <span class="n">points</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pointsRowSize</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pointsColSize</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">Ht</span> <span class="o">*</span><span class="n">ht</span> <span class="o">=</span> <span class="n">create</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pointsRowSize</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">pointsRowSize</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">dx</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">points</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">dy</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">points</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
            <span class="kt">int</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">dx</span> <span class="o">*</span> <span class="n">dx</span> <span class="o">+</span> <span class="n">dy</span> <span class="o">*</span> <span class="n">dy</span><span class="p">;</span>
            <span class="n">insert</span><span class="p">(</span><span class="n">ht</span><span class="p">,</span> <span class="n">dist</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">ht</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">struct</span> <span class="n">He</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">ht</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">q</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
                <span class="n">res</span> <span class="o">+=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">*</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
                <span class="n">free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">q</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">ht</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>Summary:</p>
<ol>
<li>179ms, 84.38%</li>
<li>Normally, I don't consider clear a hashtable and reuse it. But in this problem I have to, otherwise MLE.</li>
<li>Good problem, sometimes it is better to clear a hashtable, rather than build a huge one.</li>
</ol>
<h3><a href="https://leetcode.com/problems/island-perimeter/">463. Island Perimeter</a></h3>
<p>You are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water. Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells). The island doesn't have "lakes" (water inside that isn't connected to the water around the island). One cell is a square with side length 1. The grid is rectangular, width and height don't exceed 100. Determine the perimeter of the island.</p>
<p>Example:</p>
<div class="highlight"><pre><span></span>[[0,1,0,0],
 [1,1,1,0],
 [0,1,0,0],
 [1,1,0,0]]
</pre></div>


<ul>
<li>Answer: 16</li>
<li>Explanation: The perimeter is the 16 yellow stripes in the image below:</li>
</ul>
<p><img alt="photo" src="/images/island-perimeter.png"></p>
<p>C Solution:</p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">islandPerimeter</span><span class="p">(</span><span class="kt">int</span><span class="o">**</span> <span class="n">grid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">gridRowSize</span><span class="p">,</span> <span class="kt">int</span> <span class="n">gridColSize</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">gridRowSize</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">gridColSize</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span> <span class="k">continue</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="o">!</span><span class="n">grid</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">])</span> <span class="n">res</span><span class="o">++</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">gridRowSize</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">||</span> <span class="o">!</span><span class="n">grid</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">])</span> <span class="n">res</span><span class="o">++</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="o">!</span><span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="n">res</span><span class="o">++</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">gridColSize</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">||</span> <span class="o">!</span><span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="n">res</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">islandPerimeter</span><span class="p">(</span><span class="kt">int</span><span class="o">**</span> <span class="n">grid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">gridRowSize</span><span class="p">,</span> <span class="kt">int</span> <span class="n">gridColSize</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">island</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">disabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">gridRowSize</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">gridColSize</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span> <span class="k">continue</span><span class="p">;</span>
            <span class="n">island</span><span class="o">++</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">gridRowSize</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">])</span> <span class="n">disabled</span><span class="o">++</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">!=</span> <span class="n">gridColSize</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="n">disabled</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">island</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">-</span> <span class="n">disabled</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>Summary:</p>
<ol>
<li>The first: 89ms, 18.48%, The second: 72ms, 54.89%</li>
<li>Is this a hashtable problem?</li>
</ol>
<h2>END</h2>
                <div class="clear"></div>

                <div class="info">
                    <a href="/hash-table-easy.html">posted at 16:44</a>
                    &nbsp;&middot;&nbsp;<a href="/category/algorithm.html" rel="tag">algorithm</a>
                    &nbsp;&middot;
                    &nbsp;<a href="/tag/hashtable.html" class="tags">hashtable</a>
                    &nbsp;<a href="/tag/leetcode.html" class="tags">leetcode</a>
                </div>
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'whilerx';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
            </article>
            <div class="clear"></div>
            <footer>
                <p>
                WhileRX
            </footer>
        </div>
        <div class="clear"></div>
    </div>
    <script type="text/javascript">
    var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
    document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
    </script>
    <script type="text/javascript">
    try {
        var pageTracker = _gat._getTracker("UA-86125180-1");
    pageTracker._trackPageview();
    } catch(err) {}</script>
</body>
</html>