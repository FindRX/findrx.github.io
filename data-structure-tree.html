<!DOCTYPE html>
<html lang="en">
<head>
        <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>PU | Data Structure: Tree</title>
    <link rel="shortcut icon" type="image/png" href="/favicon.png">
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico">
    <link rel="stylesheet" href="/theme/css/screen.css" type="text/css" />
    <link rel="stylesheet" href="/theme/css/pygments.css" type="text/css" />
    <link rel="stylesheet" href="/theme/css/print.css" type="text/css" media="print" />
    <meta name="generator" content="Pelican" />
    <meta name="description" content="" />
    <meta name="author" content="ruix" />

    <meta name="keywords" content="Data-Structure" />
</head>
<body>
    <header>
        <nav>
            <ul>
                <li><a href="/">Home</a></li>
                <li><a href="/tags">Tags</a></li>
                <li><a href="/categories">Categories</a></li>
            </ul>
        </nav>
        <div class="header_box">
            <h1><a href="/">PU</a></h1>
        </div>
    </header>
    <div id="wrapper">
        <div id="content">            <h4 class="date">Oct 23, 2015</h4>

            <article class="post">
                <h2 class="title">
                    <a href="/data-structure-tree.html" rel="bookmark" title="Permanent Link to &quot;Data Structure: Tree&quot;">Data Structure: Tree</a>
                </h2>

                
                

                <hr>
<p>From bottom to top:</p>
<ul>
<li>Basic idea: <ul>
<li>First, check leaves and return a initial value.</li>
<li>Second, for no-leaf nodes, we get left-side values and right-side values.</li>
<li>merge these two values and return one or several values to the higher level.</li>
</ul>
</li>
<li>Problems <ul>
<li>Maximum Depth of Binary Tree</li>
<li>Minimum Depth of Binary Tree</li>
<li>Balanced Binary Tree</li>
<li>Lowest Common Ancestor of a Binary Search Tree [one of solutions]</li>
<li>Lowest Common Ancestor of a Binary Tree [one of solutions]</li>
<li>Binary Tree Maximum Path Sum</li>
<li>Path Sum</li>
<li>Count univalue Subtrees (perfect)</li>
<li>Diameter of Binary Tree (perfect)</li>
<li>Binary Tree Tilt (perfect)</li>
<li>Most Frequent Subtree Sum (perfect)</li>
<li>Largest BST Subtree (perfect)</li>
<li>Find Leaves of Binary Tree (perfect)</li>
<li>Lowest Common Ancestor of a Binary Tree (perfect) [with 1/2/3 sign to show whether p/q exist]</li>
</ul>
</li>
</ul>
<hr>
<p>From top to bottom:</p>
<ul>
<li>Basic idea:<ul>
<li>First, check current level or the next level and do some operations.</li>
<li>recursive call on <code>root-&gt;left</code> and <code>root-&gt;right</code>.</li>
</ul>
</li>
<li>Problems:<ul>
<li>Invert Binary Tree</li>
<li>Same Tree</li>
<li>Symmetric Tree</li>
<li>Populating Next Right Pointers in Each Node</li>
<li>Subtree of another tree</li>
<li>Validate Binary Search Tree (perfect)</li>
<li>Inorder Successor in BST</li>
<li>Binary Tree Longest Consecutive Sequence (perfect)</li>
<li>Merge Two Binary Tree (perfect)</li>
<li>Add One Row to Tree</li>
</ul>
</li>
</ul>
<hr>
<p>Inorder traversal:</p>
<ul>
<li>Binary Search Tree Iterator</li>
<li>Find Mode in Binary Search Tree</li>
<li>Recover Binary Search Tree</li>
<li>Kth Smallest Element in a BST (perfect)</li>
<li>Binary Tree Inorder Traversal (perfect)</li>
<li>Inorder Successor in BST</li>
</ul>
<hr>
<p>Preorder traversal:</p>
<ul>
<li>Binary Tree Right Side View</li>
<li>Binary Tree Preorder traversal</li>
<li>Path Sum II (perfect)</li>
<li>Sum Root to Leaf Numbers (speical)</li>
<li>Find Bottom Left Tree Value (perfect)</li>
<li>Serialize and Deserialize Binary Tree (perfect)</li>
</ul>
<hr>
<p>Postorder traversal:</p>
<ul>
<li>House Robber III (perfect)</li>
<li>Binary Tree Postorder Traversal (perfect)</li>
</ul>
<hr>
<p>BST attributes:</p>
<ul>
<li>Lowest Common Ancestor of a Binary Search Tree</li>
<li>Convert Sorted Array to Binary Search Tree</li>
<li>Closest Binary Search Tree Value</li>
<li>Delete Node in a BST (perfect)</li>
</ul>
<hr>
<p>Breadth First Search:</p>
<ul>
<li>Binary Tree Level Order Traversal</li>
<li>Binary Tree Level Order Traversal II</li>
<li>Binary Tree Right Side View</li>
<li>Binary Tree Zigzag Level Order Traversal (perfect)</li>
<li>Add One Row to Tree</li>
<li>Kill Process (perfect)</li>
</ul>
<hr>
<p>Binary Search:</p>
<ul>
<li>Closest Binary Search Tree Value</li>
</ul>
<hr>
<p>backtracking</p>
<ul>
<li>Path Sum III (perfect)</li>
</ul>
<hr>
<p>Unique Binary Search Tree: DP
Unique Binary Search Tree II: memoriation
Populating Next Right Pointers in Each Node
Populating Next Right Pointers in Each Node || (perfect)
Construct Binary Tree from Preorder and Inorder Travesal
Construct Binary Tree from Inorder and Postorder Traversal
Flatten Binary Search Tree to Linked List
Binary Tree Upside Down
Sum of Left Leaves
Average of Levels in Binary Tree (perfect)
Construct Binary Tree from String (perfect)
Find Largest Value in Each Tree Row (perfect)</p>
                <div class="clear"></div>

                <div class="info">
				<a href="/data-structure-tree.html">posted at 23:21</a>

                    &nbsp;&middot;&nbsp;<a href="/category/dsa.html" rel="tag">DSA</a>
                    &nbsp;&middot;
                    &nbsp;<a href="/tag/data-structure.html" class="tags">Data-Structure</a>
                </div>
            </article>
            <div class="clear"></div>
            <footer>
                <p>
				Try
            </footer>
        </div>
        <div class="clear"></div>
    </div>
</body>
</html>